{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>There is no doubt that building containerized applications and following a microservices architecture is one of the most common software architecture patterns observed in the past couple of years.</p> <p>Microsoft Azure offers different services to package, deploy and manage cloud-native applications, each of which serves a certain purpose and has its own pros and cons. This page provides a good comparison between the available services to host and manage cloud-native containerized applications in Azure. </p> <p>Whereas building cloud-native apps on Azure Kubernetes Service (AKS) is powerful,  there is a bit of a learning curve needed when it comes to creating and configuring the cluster, configuring networking between microservices, services discovery, certificates provisioning, and lastly managing the cluster over the lifetime of the application.</p> <p>In this workshop, we will be focusing on a containerization service offered by Microsoft Azure which is Azure Container Apps (ACA). Microsoft announced the public preview of Azure Container Apps back in Nov 2021 and in May 2022 it announced the General Availability of Azure Container Apps. In brief, Azure Container Apps is a fully managed serverless container runtime for building and running cloud-native applications which focuses on the business logic of the apps rather than on cloud infrastructure management.</p>"},{"location":"#acknowledgment","title":"Acknowledgment:","text":"<p>The workshop's material, concepts, and code samples draw inspiration from a collection of blog articles authored by Taiseer Joudeh and published on his personal blog. The workshop authors have worked collaboratively to modify and augment the content, resulting in the current version of the workshop.</p>"},{"location":"aca/00-workshop-intro/","title":"Introduction","text":""},{"location":"aca/00-workshop-intro/#description","title":"Description","text":"<p>The Building Microservice Applications with Azure Container Apps workshop will provide you with the practical knowledge to create, deploy and operate an enterprise level microservice application deployed on the latest serverless containers offering Azure Container Apps. We will demonstrate enabling different components like Dapr which will allow you to address common challenges when building an event driven distributed application while keeping your code platform agnostic. In addition to this you will get familiar with the built-in autoscaling capabilities in Azure Container Apps using KEDA and how to control spending by scaling down to zero replicas.</p>"},{"location":"aca/00-workshop-intro/#objectives-outcomes","title":"Objectives &amp; Outcomes","text":"<p>After completing the workshop, you should:</p> <ul> <li>Gain practical knowledge to create, deploy, and operate a distributed application with multiple microservices deployed to ACA.</li> <li>Setup up Dapr locally and configure VS code to support a complete local debugging experience for your distributed microservice application project.</li> <li>Use various building blocks of Dapr to simplify the building of Microservice applications, utilizing different building blocks like service-to-service Invocation using HTTP and gRPC, State management, Pub and Sub, and Input &amp; output bindings.</li> <li>Get familiar with Autoscaling feature in ACA using KEDA.</li> <li>Configure Monitoring, Observability, and distributed tracings of ACA using Application Insights.</li> <li>Setup Continuous Deployment for your microservice application using GitHub Actions.</li> <li>Recreate your entire microservice application components and generate IaC scripts using Bicep.</li> </ul>"},{"location":"aca/00-workshop-intro/1-aca-core-components/","title":"ACA Core Components Overview","text":""},{"location":"aca/00-workshop-intro/1-aca-core-components/#overview-of-azure-container-apps-core-components","title":"Overview of Azure Container Apps Core Components","text":"<p>The main components of Azure Container Apps are:</p> <p></p> <p>1. Environments The Environment is a secure boundary around several Container Apps. It contains one or more container apps. All container apps within an environment are deployed into a dedicated Azure Virtual Network, which makes it possible for these different container apps to communicate securely. In addition, all the logs produced from all container apps in the environment are sent to a dedicated Log Analytics workspace.</p> <p>2. Log Analytics Workspace Used to provide monitoring and observability functionality. Each environment will have its own Log Analytic workspace and will be shared among all container apps within the environment.</p> <p>3. Container Apps Each container App represents a single deployable unit that can contain one or more related containers. More than one container is an advanced use case. For this workshop we will deploy a single container in each container app. More about multiple containers in the same single Azure Container App can be found here.</p> <p>4. Revisions For each container app, you can create up to 100 revisions. Revisions are a way to deploy multiple versions of an app where you have the option to send the traffic to a certain revision. You can select if revision mode will support 1 active revision or multiple active revisions at the same time to support A/B testing scenarios or canary deployments. A container app running in single revision mode will have a single revision that is backed by zero-many Pods/replicas.</p> <p>5. Containers Containers in the Azure Container Apps are grouped together in pods/replicas inside revision snapshots. A Pod/replica is composed of the application container and any required sidecar containers. Containers can be deployed from any public or private container registry, and they support any Linux-based x86-64 (linux/amd64) images. At the time of creating this workshop Windows based images are not supported.</p>"},{"location":"aca/00-workshop-intro/2-scenario-architecture/","title":"Scenario and Solution Architecture","text":""},{"location":"aca/00-workshop-intro/2-scenario-architecture/#workshop-scenario","title":"Workshop Scenario","text":"<p>In this workshop we will build a tasks management application following the microservices architecture pattern. This application will consist of 3 microservices where each microservice has certain capabilities to demonstrate how ACA and Dapr can simplify the building of a microservices application. Below is the architecture diagram of the application we are going to build in this workshop.</p>"},{"location":"aca/00-workshop-intro/2-scenario-architecture/#solution-architecture","title":"Solution Architecture","text":"<ol> <li>ACA Web App-Frontend is a simple ASP.NET Razor pages web app that accepts requests from public users to manage their tasks. It invokes the component \"ACA WebAPI-Backend\" endpoints via HTTP or gRPC.</li> <li>ACA WebAPI-Backend is a backend Web API which contains the business logic of tasks management service, data storage, and publishing messages to Azure Service Bus Topic.</li> <li>ACA Processor-Backend is an event-driven backend processor which is responsible for sending emails to task owners based on messages coming from Azure Service Bus Topic. Here there is a continuously running background processor, which is based on Dapr Cron timer configuration, to flag overdue tasks.</li> <li>Autoscaling rules using KEDA are configured in the \"ACA Processor-Backend\" service to scale out/in replicas based on the the number of messages in the Azure Service Bus Topic. </li> <li>Azure Container Registry is used to build and host container images and deploy images from ACR to Azure Container Apps.</li> <li>Application Insights and Azure Log Analytics are used for Monitoring, Observability, and distributed tracings of ACA.</li> </ol>"},{"location":"aca/00-workshop-intro/3-dapr-integration/","title":"Dapr Integration in ACA","text":""},{"location":"aca/00-workshop-intro/3-dapr-integration/#dapr-overview","title":"Dapr Overview","text":"<p>As developers, we are often tasked with creating scalable, resilient, and distributed applications using microservices. But more often than not we face the same challenges: - Recovering state after failures - Services discovery and calling other microservices - Integration with external resources - Asynchronous communications between different services - Distributed tracing  - Measuring message calls and performance across components and networked services</p> <p>Dapr (Distributed Application Runtime) offers a solution for the common challenges that are faced in any distributed microservice application. Dapr can be used with any language (Go, .NET python, Node, Java, C++) and can run anywhere (On-premise, Kubernetes, and any public cloud (e.g. Azure)).</p> <p>Dapr's core component is the concept of a Building Block. So far Dapr supports 9 Building Blocks. Simply put, a Building Block is a modular component which encapsulates best practices and can be accessed over standard HTTP or gRPC APIs.</p> <p>Building Blocks address common challenges faced in building resilient microservices applications and implement best practices and patterns. Building Blocks provide consistent APIs and abstract away the implementation details to keep your code simple and portable.</p> <p>The diagram below shows the 9 Building Blocks which expose public APIs that can be called from your code, and can be configured using components to implement the building blocks\u2019 capability. Remember that you can pick whatever building block that suites your distributed microservice application and you can incorporate other building blocks as needed.</p> <p></p>"},{"location":"aca/00-workshop-intro/3-dapr-integration/#dapr-microservices","title":"Dapr &amp; Microservices","text":"<p>Dapr exposes its Building Blocks and components through a sidecar architecture. A sidecar enables Dapr to run in a separate memory process or separate container alongside your service. Sidecars provide isolation and encapsulation as they aren't part of the service, but connected to it. This separation enables each service to have its own runtime environment and be built upon different programming platforms.</p> <p></p> <p>This pattern is named Sidecar because it resembles a sidecar attached to a motorcycle. In the previous figure, note how the Dapr sidecar is attached to your service to provide distributed application capabilities.</p>"},{"location":"aca/00-workshop-intro/3-dapr-integration/#dapr-usage-in-the-workshop","title":"Dapr usage in the workshop","text":"<p>We are going to enable Dapr for all Azure Container Apps in the solution, the Dapr APIs/Building Blocks used in this workshop are:</p> <ul> <li>Service to Service invocation: \"ACA Web App-Frontend\" microservice invokes the \"ACA WebAPI-Backend\" microservice using Dapr sidecar via the Service-to-service invocation building block</li> <li>State Management: \"ACA WebAPI-Backend\" stores data on Azure Cosmos DB and stores email logs on Azure Table Storage using Dapr State Management building blocks.</li> <li>Pub/Sub: \"ACA WebAPI-Backend\" publishes messages to Azure Service Bus when a task is saved and the \"ACA Processor-Backend\" microservices consumes those messages and sends emails using SendGrid.</li> <li>Bindings: \"ACA Processor-Backend\" is triggered based on an incoming event such as a Cron job.</li> </ul>"},{"location":"aca/00-workshop-intro/4-prerequisites/","title":"Prerequisites","text":""},{"location":"aca/00-workshop-intro/4-prerequisites/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have your development environment setup and configured.</p> <ol> <li>An Azure account with an active subscription - Create an account for free</li> <li>Use GitHub Codespaces - Create a Codespace</li> <li>Azure CLI - Install     Run: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash</li> </ol>"},{"location":"aca/00-workshop-intro/4-prerequisites/#workshop-instructions","title":"Workshop Instructions","text":"<p>The workshop is divided into separate modules. Each module will guide you through building the solution code step-by-step. Ensure that you finish the modules in the right order as they have dependency on each other.</p> <p>If you don't want to build the solution code from scratch, you can clone the source code repository final version by utilizing below command, and you can use the modules to deploy Azure resources using the provided Azure CLI commands.</p> <pre><code>git clone https://github.com/Azure/aca-dotnet-workshop.git\n</code></pre> <p>If you are using GitHub Codespaces, just install Azure CLI and you are ready to go.</p>"},{"location":"aca/01-deploy-api-to-aca/","title":"Module 1 - Deploy Backend API to Azure Containers Apps (ACA)","text":"<p>Module Duration</p> <p>30 minutes</p> <p>In this module, we will start by creating the first microservice named <code>ACA Web API \u2013 Backend</code> as illustrated in the architecture diagram. Followed by that we will provision the  Azure resources needed to deploy the service to Azure Container Apps using the Azure CLI.</p>"},{"location":"aca/01-deploy-api-to-aca/#1-deploy-web-api-backend-project-to-aca","title":"1. Deploy Web API Backend Project to ACA","text":"<p>We will be using Azure CLI to deploy the Web API Backend to ACA as shown in the following steps:</p> <ul> <li> <p>We will start with Installing/Upgrading the Azure Container Apps Extension.     <pre><code># Upgrade Azure CLI\naz upgrade\n# Login to Azure\naz login --use-device-code\n# Only required if you have multiple subscriptions\naz account set --subscription &lt;name or id&gt;\n# Install/Upgrade Azure Container Apps Extension\naz extension add --name containerapp --upgrade\n</code></pre></p> </li> <li> <p>Define the variables below in the PowerShell console to use them across the different modules in the workshop. You should change the values of those variables to be able to create the resources successfully. Some of those variables should be unique across all Azure subscriptions such as Azure Container Registry name. Remember to replace the place holders with your own values:</p> <pre><code>export RESOURCE_GROUP=\"tasks-tracker-rg\"\nexport LOCATION=\"eastus\"\nexport ENVIRONMENT=\"tasks-tracker-containerapps-env\"\nexport WORKSPACE_NAME=\"&lt;replace this with your unique app log analytics workspace name&gt;\"\nexport APPINSIGHTS_NAME=\"&lt;replace this with your unique app insights name&gt;\"\nexport BACKEND_API_NAME=\"tasksmanager-backend-api\"\nexport ACR_NAME=\"&lt;replace this with your unique acr name&gt;\"\nexport YOUR_ACA_ENV_UNIQUE_ID=\"&lt;replace this with your initialls and the current day, e.g.: rbb053020&gt;\"\n</code></pre> </li> <li> <p>Create a <code>resource group</code> to organize the services related to the application, run the below command:     <pre><code>az group create \\\n--name $RESOURCE_GROUP \\\n--location \"$LOCATION\"\n</code></pre></p> </li> <li> <p>Create an Azure Container Registry (ACR) instance in the resource group to store images of all Microservices we are going to build during this workshop. Make sure that you set the <code>admin-enabled</code> flag to true in order to seamlessly authenticate the Azure container app when trying to create the container app using the image stored in ACR</p> <pre><code>az acr create \\\n--resource-group $RESOURCE_GROUP \\\n--name $ACR_NAME \\\n--sku Basic \\\n--admin-enabled true\n</code></pre> </li> </ul> <p>Note</p> <p>Notice that we create the registry with admin rights <code>--admin-enabled</code> flag set to <code>true</code> which is not suited for real production, but good for our workshop.</p> <ul> <li>Create an Azure Log Analytics Workspace which will provide a common place to store the system and application log data from all container apps running in the environment. Each environment should have its own Log Analytics Workspace. To create it, run the command below:     <pre><code># create the log analytics workspace\naz monitor log-analytics workspace create \\\n--resource-group $RESOURCE_GROUP \\\n--workspace-name $WORKSPACE_NAME\n# retrieve workspace ID\nexport WORKSPACE_ID=$(az monitor log-analytics workspace show --query customerId \\\n-g $RESOURCE_GROUP \\\n-n $WORKSPACE_NAME -o tsv)\n# retrieve workspace secret\nexport WORKSPACE_SECRET=$(az monitor log-analytics workspace get-shared-keys --query primarySharedKey \\\n-g $RESOURCE_GROUP \\\n-n $WORKSPACE_NAME -o tsv)\n</code></pre></li> <li> <p>Create an Application Insights Instance which will be used mainly for distributed tracing between different container apps within the ACA environment to provide searching for and visualizing an end-to-end flow of a given execution or transaction. To create it, run the command below:     <pre><code># Install the application-insights extension for the CLI\naz extension add -n application-insights\n\n# Create application-insights instance\naz monitor app-insights component create \\\n-g $RESOURCE_GROUP \\\n-l $LOCATION \\\n--app $APPINSIGHTS_NAME \\\n--workspace $WORKSPACE_NAME\n# Get Application Insights Instrumentation Key\nexport APPINSIGHTS_INSTRUMENTATIONKEY=$(az monitor app-insights component show \\\n--app $APPINSIGHTS_NAME -g $RESOURCE_GROUP | jq -r '.instrumentationKey')\n</code></pre></p> </li> <li> <p>Now we will create an Azure Container Apps Environment. As a reminder of the different ACA component check this link in the workshop introduction. The ACA environment acts as a secure boundary around a group of container apps that we are going to provision during this workshop. To create it, run the below command:     <pre><code># Create the ACA environment\naz containerapp env create \\\n--name $ENVIRONMENT \\\n--resource-group $RESOURCE_GROUP \\\n--logs-workspace-id $WORKSPACE_ID \\\n--logs-workspace-key $WORKSPACE_SECRET \\\n--dapr-instrumentation-key $APPINSIGHTS_INSTRUMENTATIONKEY \\\n--location $LOCATION\n</code></pre></p> </li> </ul> Want to learn what above command does? <ul> <li>It creates an ACA environment and associates it with the Log Analytics Workspace created in the previous step.</li> <li>We are setting the <code>--dapr-instrumentation-key</code> value to the instrumentation key of the Application Insights instance. This will come handy when we introduce Dapr in later modules and show how the distributed tracing between microservices/container apps are captured and visualized in Application Insights.   <p>NOTE: You can set the <code>--dapr-instrumentation-key</code> after you create the ACA environment but this is not possible via the AZ CLI right now. There is an open issue which is being tracked by the product group.</p> </li> </ul> <ul> <li> <p>Build the Web API project on ACR and push the docker image to ACR. Use the below command to initiate the image build and push process using ACR. The <code>.</code> at the end of the command represents the docker build context, in our case, we need to be on the parent directory which hosts the <code>.csproj</code>.</p> <p><pre><code>az acr build --registry $ACR_NAME --image \"tasksmanager/$BACKEND_API_NAME\" --file 'TasksTracker.TasksManager.Backend.Api/Dockerfile' .\n</code></pre> Once this step is completed you can verify the results by going to the Azure portal and checking that a new repository named <code>tasksmanager/tasksmanager-backend-api</code> has been created and there is a new docker image with a <code>latest</code> tag is created.</p> </li> <li> <p>The last step here is to create and deploy the Web API to ACA following the below command. Remember to replace the place holders with your own values:</p> <pre><code>az containerapp create \\\n--name $BACKEND_API_NAME  \\\n--resource-group $RESOURCE_GROUP \\\n--environment $ENVIRONMENT \\\n--image \"$ACR_NAME.azurecr.io/tasksmanager/$BACKEND_API_NAME:latest\" \\\n--registry-server \"$ACR_NAME.azurecr.io\" \\\n--target-port 80 \\\n--ingress 'external' \\\n--min-replicas 1 \\\n--max-replicas 1 \\\n--cpu 0.25 --memory 0.5Gi \\\n--query configuration.ingress.fqdn\n</code></pre> </li> </ul> Want to learn what above command does? <ul> <li>Ingress param is set to <code>external</code> which means that this container app (Web API) project will be accessible from the public internet. When Ingress is set to <code>Internal</code> or <code>External</code> it will be assigned a fully qualified domain name (FQDN). Important notes about IP addresses and domain names can be found here.</li> <li>The target port param is set to 80, this is the port our Web API container listens to for incoming requests.</li> <li>We didn't specify the ACR registry username and password, <code>az containerapp create</code> command was able to look up ACR username and password and add them as a secret under the created Azure container app for future container updates.</li> <li>The minimum and the maximum number of replicas are set. More about this when we cover Autoscaling in later modules. For the time being, only a single instance of this container app will be provisioned as Auto scale is not configured.</li> <li>We set the size of the Container App. The total amount of CPUs and memory requested for the container app must add up to certain combinations, for full details check the link here.</li> <li>The <code>query</code> property will filter the response coming from the command and just return the FQDN. Take note of this FQDN as you will need it for the next step.</li> </ul> <p>For full details on all available parameters for this command, please visit this page.  </p> <ul> <li>You can now verify the deployment of the first ACA by navigating to the Azure Portal and selecting the resource group named <code>tasks-tracker-rg</code> that you created earlier. You should see the 5 recourses created below. </li> </ul> <p>Success</p> <p>To test the backend api service, copy the FQDN (Application URL) of the Azure container app named <code>tasksmanager-backend-api</code>.  Issue a <code>GET</code> request similar to this one: <code>https://tasksmanager-backend-api.&lt;your-aca-env-unique-id&gt;.eastus.azurecontainerapps.io/api/tasks/?createdby=tjoudeh@bitoftech.net</code> and you should receive an array of the 10 tasks similar to the below image.</p> <p>Tip</p> <p>You can find your azure container app application url on the azure portal overview tab.</p> <p></p> <p>In the next module, we will see how we will add a new Frontend Web App as a microservice and how it will communicate with the backend API.</p>"},{"location":"aca/02-aca-comm/","title":"Module 2 - Communication Between Microservices in Azure Containers Apps (ACA)","text":"<p>Module Duration</p> <p>60 minutes</p> <p>In this module, we will add a service named <code>ACA Web API \u2013 Frontend</code> as illustrated in the architecture diagram. This service will host a simple ASP.NET Razor pages web app which allows the end users to manage their tasks. After that we will provision Azure resources needed to deploy the service to ACA using Azure CLI.</p>"},{"location":"aca/02-aca-comm/#1-deploy-razor-pages-web-app-frontend-project-to-aca","title":"1. Deploy Razor Pages Web App Frontend Project to ACA","text":"<p>We will assume that you still have the same PowerShell console session opened from the last module which has all the powershell variables defined from module 1. We need to add the below PS variables:</p> <p><pre><code>export FRONTEND_WEBAPP_NAME=\"tasksmanager-frontend-webapp\"\n</code></pre> - Now we will build and push the Web App project docker image to ACR. Use the below command to initiate the image build and push process using ACR. The <code>.</code> at the end of the command represents the docker build context. In our case, we need to be on the parent directory which hosts the .csproject.</p> <p><pre><code>az acr build --registry $ACR_NAME --image \"tasksmanager/$FRONTEND_WEBAPP_NAME\" --file 'TasksTracker.WebPortal.Frontend.Ui/Dockerfile' .\n</code></pre> Once this step is completed you can verify the results by going to the Azure portal and checking that a new repository named <code>tasksmanager/tasksmanager-frontend-webapp</code> has been created and there is a new docker image with a <code>latest</code> tag is created.</p> <ul> <li>Next, we will create and deploy the Web App to ACA using the following command. Remember to replace the placeholders with your own values:</li> </ul> <pre><code>az containerapp create \\\n--name \"$FRONTEND_WEBAPP_NAME\" \\\n--resource-group $RESOURCE_GROUP \\\n--environment $ENVIRONMENT \\\n--image \"$ACR_NAME.azurecr.io/tasksmanager/$FRONTEND_WEBAPP_NAME:latest\" \\\n--registry-server \"$ACR_NAME.azurecr.io\" \\\n--env-vars \"BackendApiConfig__BaseUrlExternalHttp=&lt;url to your backend api goes here. You can find this on the azure portal overview tab. Look for the Application url property there.&gt;/\" \\\n--target-port 80 \\\n--ingress 'external' \\\n--min-replicas 1 \\\n--max-replicas 1 \\\n--cpu 0.25 --memory 0.5Gi \\\n--query configuration.ingress.fqdn\n</code></pre> <p>Tip</p> <p>Notice how we used the property <code>env-vars</code> to set the value of the environment variable named <code>BackendApiConfig_BaseUrlExternalHttp</code> which we added in the AppSettings.json file. You can set multiple environment variables at the same time by using a space between each variable. The <code>ingress</code> property is set to <code>external</code> as the Web frontend App will be exposed to the public internet for users.</p> <p>After your run the command, copy the FQDN (Application URL) of the Azure container app named <code>tasksmanager-frontend-webapp</code> and open it in your browser, and you should be able to browse the frontend web app and manage your tasks.</p>"},{"location":"aca/02-aca-comm/#3-update-backend-web-api-container-app-ingress-property","title":"3. Update Backend Web API Container App Ingress property","text":"<p>So far the Frontend App is sending HTTP requests to publicly exposed Web API which means that any REST client can invoke this API. We need to change the Web API ingress settings and make it only accessible for applications deployed within our Azure Container Environment only. Any application outside the Azure Container Environment will not be able to access the Web API.</p> <ul> <li> <p>To change the settings of the Backend API, execute the following command:</p> <pre><code>az containerapp ingress enable \\\n--name  $BACKEND_API_NAME  \\\n--resource-group  $RESOURCE_GROUP \\\n--target-port 80 \\\n--type \"internal\"\n</code></pre> </li> </ul> Want to know more about the command? <p>When you do this change, the FQDN (Application URL) will change, and it will be similar to the one shown below. Notice how there is an <code>Internal</code> part of the URL. <code>https://tasksmanager-backend-api.internal.[Environment unique identifier].eastus.azurecontainerapps.io/api/tasks/</code></p> <p>If you try to invoke the URL from the browser directly it will return 404 as this Internal Url can only be accessed from container apps within the container environment.</p> <p>The FQDN consists of multiple parts. For example, all our Container Apps will be under a specific Environment unique identifier (e.g. <code>agreeablestone-8c14c04c</code>) and the Container App will vary based on the name provided, check the image below for a better explanation. </p> <ul> <li> <p>Now we will need to update the Frontend Web App environment variable to point to the internal backend Web API FQDN. The last thing we need to do here is to update the Frontend WebApp environment variable named <code>BackendApiConfig_BaseUrlExternalHttp</code> with the new value of the internal Backend Web API base URL, to do so we need to update the Web App container app and it will create a new revision implicitly (more about revisions in the upcoming modules). The following command will update the container app with the changes:</p> <pre><code>az containerapp update \\\n--name \"$FRONTEND_WEBAPP_NAME\"  \\\n--resource-group $RESOURCE_GROUP \\\n--set-env-vars \"BackendApiConfig__BaseUrlExternalHttp=https://tasksmanager-backend-api-$YOUR_ACA_ENV_UNIQUE_ID.internal.[Environment unique identifier].eastus.azurecontainerapps.io\"\n</code></pre> </li> </ul> <p>Success</p> <p>Browse the web app again, and you should be able to see the same results and access the backend API endpoints from the Web App.</p>"},{"location":"aca/03-deploy-api-to-aci/","title":"Module 3 - Deploy the same backend image but now using Azure Container instances","text":"<p>Module Duration</p> <p>20 minutes</p> <p>In this module, we weill reuse the same backend API and deploy it to Azure Container Instances (ACI). We will then deploy the same frontend web app and integrate both using Azure Container Instances.</p>"},{"location":"aca/03-deploy-api-to-aci/#benefits-of-using-azure-container-instances","title":"Benefits of using Azure Container Instances","text":"<ul> <li>No VM management required</li> <li>No cluster management required</li> <li>Fastest and simplest way to run a container in Azure</li> <li>Billing by the second</li> <li>Integrate with Azure Virtual Network</li> <li>Integrate with Azure Container Registry</li> <li>Integrate with Azure Monitor</li> <li>Integrate with Azure Key Vault</li> <li>Etc..</li> </ul>"},{"location":"aca/03-deploy-api-to-aci/#deploy-azure-container-instances-using-the-previous-image-storage-on-azure-container-registry","title":"Deploy Azure container instances using the previous image storage on Azure Container Registry","text":""},{"location":"aca/03-deploy-api-to-aci/#get-the-acr-username-and-password","title":"Get the ACR Username and Password","text":"<pre><code>export acrpss=$(az acr credential show --name $ACR_NAME --query \"passwords[0].value\" -o tsv)\nexport acrusr=$(az acr credential show --name $ACR_NAME --query \"username\" -o tsv)\naz container create --resource-group $RESOURCE_GROUP --name $BACKEND_API_NAME --image \"$ACR_NAME.azurecr.io/tasksmanager/$BACKEND_API_NAME:latest\" --registry-login-server \"$ACR_NAME.azurecr.io\" --registry-username $acrusr --registry-password $acrpss --dns-name-label $BACKEND_API_NAME-$YOUR_ACA_ENV_UNIQUE_ID --ports 80\n</code></pre> <p>Success</p> <p>To test the backend api service, copy the FQDN (Application URL) of the Azure container app named <code>tasksmanager-backend-api</code>.  Issue a <code>GET</code> request similar to this one: <code>https://tasksmanager-backend-api&lt;YOUR_ACA_ENV_UNIQUE_ID&gt;.eastus.azurecontainer.io/api/tasks/?createdby=tjoudeh@bitoftech.net</code> and you should receive an array of the 10 tasks similar to the below image.</p> <p>Tip</p> <p>You can find your azure container instances app application url on the azure portal overview tab.</p> <p></p>"},{"location":"aca/04-deploy-api-to-app/","title":"Module 4 - Deploy Frontend App to Azure App Service and integrate with Azure Container intance App running Backend API","text":"<p>Module Duration</p> <p>20 minutes</p> <p>In this module, we will deploy the frontend web app to Azure App Service and integrate it with the backend API running on Azure Container Instances.</p> <p>The goal is to confirm that images you build to run on Azure can run in multiple environments. In this case, we will run the frontend web app on Azure App Service and the backend API on Azure Container Instances.</p>"},{"location":"aca/04-deploy-api-to-app/#overview-of-app-service","title":"Overview of App Service","text":"<p>Azure App Service is a fully managed web hosting service for building web apps, mobile back ends, and RESTful APIs. It provides out-of-the-box support for authentication, push notifications, offline sync, and more. You can also add your own REST APIs to enable your app scenarios.</p>"},{"location":"aca/04-deploy-api-to-app/#deploy-an-app-service-plan","title":"Deploy an App Service plan","text":"<pre><code>az appservice plan create --resource-group $RESOURCE_GROUP --name pam$FRONTEND_WEBAPP_NAME --sku S1 --is-linux\n</code></pre>"},{"location":"aca/04-deploy-api-to-app/#deploy-the-frontend-web-app-to-azure-app-service-using-the-image-from-azure-container-registry","title":"Deploy the frontend web app to Azure App Service using the image from Azure Container Registry","text":"<pre><code>az webapp create --resource-group $RESOURCE_GROUP --plan pam$FRONTEND_WEBAPP_NAME --name $FRONTEND_WEBAPP_NAME-$YOUR_ACA_ENV_UNIQUE_ID --deployment-container-image-name \"$ACR_NAME.azurecr.io/tasksmanager/$FRONTEND_WEBAPP_NAME:latest\"\n</code></pre>"},{"location":"aca/04-deploy-api-to-app/#update-the-backend-api-url-to-the-azure-container-instances-app-url","title":"Update the backend API URL to the Azure Container Instances App URL","text":"<pre><code>az webapp config appsettings set --resource-group $RESOURCE_GROUP --name $FRONTEND_WEBAPP_NAME-$YOUR_ACA_ENV_UNIQUE_ID --settings BackendApiConfig__BaseUrlExternalHttp=http://tasksmanager-backend-api-$YOUR_ACA_ENV_UNIQUE_ID.eastus.azurecontainer.io\n</code></pre> <p>Success</p> <p>Browse the web app , and you should be able to see the same results and access the backend API endpoints from the Web App but now we are using Web Apps + Container Instances.</p> <p>In the next module we will start to deploy the same app but now using Azure Kubernetes Service (AKS).</p>"},{"location":"aca/05-deploy-api-to-aks/","title":"Module 5 - Deploy Frontend and Backend to Azure Kubernetes Service (AKS)","text":"<p>Module Duration</p> <p>30 minutes</p> <p>In this module we will deploy the frontend and backend to Azure Kubernetes Service (AKS). We will use the same images deployed to Azure Container Registry (ACR) in the previous module.</p> <p>The goal is to see how different services in Azure can accomodate your strategy to deploy containerized applications.</p>"},{"location":"aca/05-deploy-api-to-aks/#overview-of-azure-kubernetes-service-aks","title":"Overview of Azure Kubernetes Service (AKS)","text":"<p>Azure Kubernetes Service (AKS) manages your hosted Kubernetes environment, making it quick and easy to deploy and manage containerized applications without container orchestration expertise. It also eliminates the burden of ongoing operations and maintenance by provisioning, upgrading, and scaling resources on demand, without taking your applications offline.</p>"},{"location":"aca/05-deploy-api-to-aks/#deploy-an-aks-integrated-with-azure-container-registry-acr","title":"Deploy an AKS integrated with Azure Container Registry (ACR)","text":"<pre><code>az aks create --resource-group $RESOURCE_GROUP --name aks-$YOUR_ACA_ENV_UNIQUE_ID --node-count 1 --enable-addons monitoring --generate-ssh-keys --attach-acr $ACR_NAME\n</code></pre>"},{"location":"aca/05-deploy-api-to-aks/#get-aks-credentials","title":"Get AKS credentials","text":"<pre><code>az aks get-credentials --resource-group $RESOURCE_GROUP --name aks-$YOUR_ACA_ENV_UNIQUE_ID\n</code></pre>"},{"location":"aca/05-deploy-api-to-aks/#configure-your-yaml-files","title":"Configure your yaml files","text":"<p>Edit the file deploy-frontend.yaml and replace the value  with your ACR name. <p>Edit the file deploy-backend.yaml and replace the value  with your ACR name."},{"location":"aca/05-deploy-api-to-aks/#deploy-frontend-and-backend-to-aks","title":"Deploy frontend and backend to AKS","text":"<pre><code>cd docs/aca/05-deploy-api-to-aks\n\nkubectl apply -f ./deploy-backend.yaml\n\nkubectl apply -f ./deploy-frontend.yaml\n</code></pre>"},{"location":"aca/05-deploy-api-to-aks/#get-the-ip-address-of-the-frontend-web-app","title":"Get the IP address of the frontend web app","text":"<pre><code>kubectl get service frontend-service\n</code></pre> <p>If the previous command doesn't return the external IP address of the frontend web app, you can wait and try again after 10 seconds.</p> <p>Success</p> <p>Browse the web app using the IP you got from the previous command, use the following email: tjoudeh@bitoftech.net , you should be able to see the same results and access the backend API endpoints from the Web App but now we are using Kubernetes services.</p>"},{"location":"aca/06-aca-iac-bicep/","title":"Module 6 - Deployment Via Bicep and DevOps","text":"<p>Throughout the various modules, we have utilized various Azure CLI commands to provision different resources. While this approach is suitable for this workshop, in a production environment, you will likely require a more automated process to deploy the same resources. In this module, we will be working on defining the proper process to automate the infrastructure provisioning by creating the scripts/templates to provision the resources. This process is known as IaC (Infrastructure as Code).</p> <p>Once we have this in place, IaC deployments will benefit us in key ways such as:</p> <ol> <li>By ensuring consistency and reducing human errors in resource provisioning, deployments can be made with greater confidence and consistency.</li> <li>Avoid configuration drifts as IaC is an idempotent operation, which means it provides the same result each time it\u2019s run.</li> <li>With Infrastructure as Code (IaC) in place, recreating an identical environment to the production one becomes a simple task of executing the scripts. This can be particularly useful during the application's lifecycle when short-term isolation is needed for tasks such as penetration testing or load testing.</li> <li>The Azure Portal abstracts several processes when you provision resources. For instance, when you create an Azure Container Apps Environment from the portal, it automatically creates a log analytics workspace and associates it with the environment without your direct involvement. However, using Infrastructure as Code (IaC) can provide you with a deeper understanding of Azure and help you troubleshoot any issues that may arise more effectively.</li> </ol>"},{"location":"aca/06-aca-iac-bicep/#arm-templates-in-azure","title":"ARM Templates in Azure","text":"<p>ARM templates are files that define the infrastructure and configuration for your deployment. The templates use declarative syntax, which lets you state what you intend to deploy without having to write the sequence of programming commands to create it.</p> <p>Within Azure there are two ways to create IaC. We can either use the JSON ARM templates or Bicep (domain-specific language). As a project grows and the number of components and dependencies increases, working with JSON ARM templates in real-world scenarios can become increasingly complex and difficult to manage and maintain. Bicep provides a more user-friendly and straightforward experience when compared to ARM templates, resulting in increased productivity. However, it's worth noting that Bicep code is eventually compiled into ARM templates through a process called \"transpilation.\"</p> <p></p> <p>Tip</p> <p>For those interested in learning more about Bicep, it is recommended to visit the Microsoft Learn website Fundamentals of Bicep.</p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/","title":"Deploy Infrastructure Using Azure DevOps","text":"<p>Module Duration</p> <p>30 minutes</p> <p>In the previous section, we demonstrated how Bicep scripts can be used to automate the deployment of infrastructure components. However, creating the container registry and deploying the Bicep scripts using the Azure CLI still required manual effort. For a more efficient and streamlined process, it's preferable to use automation. Azure DevOps is a great solution for automating workflows, and in this section, we'll explain how to create a Azure DevOps pipeline for deploying the infrastructure components of our application.</p> <p>The workshop repository contains a Azure Devops Pipeline yaml file that will be used to deploy the infrastructure components of our application. Follow the steps below to create a devops pipeline to deploy the infrastructure components of our application.</p> <p>Note<p>The following instructions assume that you will utilize the forked Github repository both as the host for your YAML pipeline and the source code. However, it is possible to host the same assets in your Azure DevOps repository instead, if that is your preference. It is important to remember that if you choose to store your assets in your Azure DevOps repository, you will have to direct your Azure DevOps pipeline towards the Azure DevOps repository instead of the Github repository.</p> </p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#fork-the-github-repository","title":"Fork the GitHub repository","text":"<p>Start by forking the workshop repository to your GitHub account. Follow the steps below to fork the workshop:</p> <ol> <li>Navigate to the workshop repository at  Azure/aca-dotnet-workshop</li> <li>Click the Fork button in the top-right corner of the page.</li> <li>Select your GitHub account to fork the repository to.</li> <li>Wait for the repository to be forked.</li> </ol>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#configure-a-service-connection-for-github-and-azure-subscription","title":"Configure a Service Connection for GitHub and Azure Subscription","text":"<p>Before we start with creating pipeline, we need to configure service connection for GitHub and Azure Subscription. You can do this in either existing or new project.</p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#create-a-service-connection-for-github","title":"Create a Service Connection for GitHub","text":"<p>Provide access to the repository forked above by creating a service connection to GitHub. You create a new pipeline by first selecting a GitHub repository and then a YAML file in repository at path .ado/infra-deploy.yml. </p> <p>The repository in which the YAML file is present is called self repository. By default, this is the repository that your pipeline builds.</p> <p>There are three authentication types for granting Azure Pipelines access to your GitHub repositories while creating  a pipeline. Follow guide at this link to create service connection for GitHub.</p> <p></p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#create-service-connection-for-azure-subscription","title":"Create Service Connection for Azure Subscription","text":"<p>Create a new service connection to your azure subscription by following the steps at this link.</p> <p>Note</p> <p>Update the created service connection role to have User Access Administrator role. This is required for pipeline to be able to perform role assignments in the infrastructure components deployed. To update the role of a service connection in Azure DevOps to have the User Access Administrator role, you can follow these steps:</p> <ul> <li> <p>Navigate to the Azure portal and select the subscription where the service connection is created.</p> </li> <li> <p>Click on Access control (IAM) in the left-hand menu.</p> </li> <li> <p>Click on Add role assignment.</p> </li> <li> <p>For the Assignment type choose Privileged administrator roles.</p> </li> <li> <p>In the Role section choose User Access Administrator.</p> </li> <li> <p>In the Members section, search for the name of the service connection that you want to update and select it.</p> </li> <li> <p>Click Save to apply the changes.</p> </li> </ul>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#configure-variable-group-under-azure-devops-library-section","title":"Configure Variable Group under Azure DevOps Library Section","text":"<p>Create a variable group named AcaApp under Library in your Azure Devops project. Make sure the pipeline has permissions to access the created variable group under Pipeline permissions.</p> <p>This variable group will be used to store below details:</p> <pre><code># AZURE_SUBSCRIPTION: Name of the service connection created for Azure Subscription\nAZURE_SUBSCRIPTION=&lt;service connection name&gt;\n\n# LOCATION: Azure region where resources will be deployed\nLOCATION=&lt;location&gt;\n\n# RESOURCE_GROUP: Name of the resource group which will be created and where the resources will be deployed\nRESOURCE_GROUP=&lt;resource group name&gt;\n\n# (OPTIONAL)CONTAINER_REGISTRY_NAME: Unique name of the container registry which will be created and where images will be imported\nCONTAINER_REGISTRY_NAME=&lt;container registry name&gt;\n</code></pre> <p>Note</p> <p>Repository variable <code>CONTAINER_REGISTRY_NAME</code> is only needed by pipeline if you intend to deploy images from a private Azure Container Registry (ACR). You may chose to skip defining this variable and the pipeline will use the public github container registry images to deploy the images.</p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-azdo/#trigger-azure-devops-pipeline","title":"Trigger Azure Devops Pipeline","text":"<p>With these steps completed, you are now ready to trigger the Pipeline.</p> <p>Success</p> <p>Your Pipeline should be triggered and the infrastructure components of our application should be deployed successfully.</p> <p></p> Want to delete the resources deployed by the pipeline? <p>Trigger the pipeline again select checkbox option named Should teardown infrastructure?.</p> <p></p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/","title":"Deploy Infrastructure Using GitHub Actions","text":"<p>Module Duration</p> <p>30 minutes</p> <p>In the previous section, we demonstrated how Bicep scripts can be used to automate the deployment of infrastructure components. However, creating the container registry and deploying the Bicep scripts using the Azure CLI still required manual effort. For a more efficient and streamlined process, it's preferable to use automation. GitHub Actions is a great solution for automating workflows, and in this section, we'll explain how to create a GitHub Action workflow for deploying the infrastructure components of our application.</p> <p>The workshop repository contains a GitHub Action workflow file that will be used to deploy the infrastructure components of our application. Follow the steps below to create a GitHub Action workflow to deploy the infrastructure components of our application.</p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/#fork-the-github-repository","title":"Fork the GitHub repository","text":"<p>Start by forking the workshop repository to your GitHub account. Follow the steps below to fork the workshop:</p> <ol> <li>Navigate to the workshop repository at  Azure/aca-dotnet-workshop</li> <li>Click the Fork button in the top-right corner of the page.</li> <li>Select your GitHub account to fork the repository to.</li> <li>Wait for the repository to be forked.</li> </ol>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/#configure-repository-for-oidc-authentication-with-azure-ad","title":"Configure Repository for OIDC Authentication with Azure AD","text":"<p>In order to use the GitHub Actions workflow to deploy the infrastructure components of our application, we need to  log in to Azure using the Azure CLI with Azure login action.</p> <p>The Azure login action supports two different ways of authenticating with Azure:</p> <ul> <li>Service principal with secrets</li> <li>OpenID Connect (OIDC) with a Azure service principal using a Federated Identity Credential</li> </ul> <p>In this workshop, we will use the OIDC authentication method. Assuming you are already logged in using azure cli  locally, follow the steps below to configure the repository for OIDC authentication with Azure AD either using powershell or bash/wsl:</p> PowerShellBash/WSL <ul> <li>Execute the following commands in PowerShell to create an Azure AD application and service principal.</li> </ul> <pre><code>$AZURE_TENANT = az account show -o tsv --query tenantId\n$SUBSCRIPTION_ID = az account show -o tsv --query id\n$APP_ID = az ad app create --display-name aca-dotnet-workshop-oidc --query appId -otsv\naz ad sp create --id $APP_ID --query appId -otsv\n$OBJECT_ID = az ad app show --id $APP_ID --query id -otsv\n</code></pre> <ul> <li>Execute below command to create a federated identity credential for the Azure AD application.</li> </ul> <p>Note</p> <p>Replace <code>&lt;Repo owner&gt;</code> in below json with your GitHub username where you forked the workshop repository.</p> <pre><code>az rest --method POST --uri \"https://graph.microsoft.com/beta/applications/$OBJECT_ID/federatedIdentityCredentials\" --body '{\\\"name\\\":\\\"aca-dotnet-workshop-federated-identity\\\",\\\"issuer\\\":\\\"https://token.actions.githubusercontent.com\\\",\\\"subject\\\":\\\"repo:&lt;Repo owner&gt;/aca-dotnet-workshop:ref:refs/heads/main\\\",\\\"description\\\":\\\"GitHub\\\",\\\"audiences\\\":[\\\"api://AzureADTokenExchange\\\"]}' --headers \"Content-Type=application/json\"\n</code></pre> <ul> <li>Perform role assignment for the Azure AD application to access the subscription.</li> </ul> <pre><code>az role assignment create --assignee $APP_ID --role contributor --scope /subscriptions/$SUBSCRIPTION_ID\naz role assignment create --assignee $APP_ID --role 'User Access Administrator' --scope /subscriptions/$SUBSCRIPTION_ID\n</code></pre> <ul> <li>Execute the following commands in PowerShell to create an Azure AD application and service principal.</li> </ul> <pre><code>AZURE_TENANT = $(az account show -o tsv --query tenantId)\nSUBSCRIPTION_ID = $(az account show -o tsv --query id)\nAPP_ID = $(az ad app create --display-name serverless-webapp-kotlin-oidc --query appId -otsv)\naz ad sp create --id $APP_ID --query appId -otsv\n\nOBJECT_ID = $(az ad app show --id $APP_ID --query id -otsv)\n</code></pre> <ul> <li>Execute below command to create a federated identity credential for the Azure AD application.</li> </ul> <p>Note</p> <p>Replace <code>&lt;Repo owner&gt;</code> in below json with your GitHub username where you forked the workshop repository.</p> <pre><code>cat &lt;&lt;EOF &gt; body.json\n{\n    \"name\": \"aca-dotnet-workshop-federated-identity\",\n    \"issuer\": \"https://token.actions.githubusercontent.com\",\n    \"subject\": \"repo:&lt;Repo owner&gt;/aca-dotnet-workshop:ref:refs/heads/main\",\n    \"description\": \"GitHub\",\n    \"audiences\": [\n        \"api://AzureADTokenExchange\"\n    ]\n}\nEOF\naz rest --method POST --uri \"https://graph.microsoft.com/beta/applications/$OBJECT_ID/federatedIdentityCredentials\" --body @body.json\n</code></pre> <ul> <li>Perform role assignment for the Azure AD application to access the subscription.</li> </ul> <pre><code>az role assignment create --assignee $APP_ID --role contributor --scope /subscriptions/$SUBSCRIPTION_ID\naz role assignment create --assignee $APP_ID --role 'User Access Administrator' --scope /subscriptions/$SUBSCRIPTION_ID\n</code></pre>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/#configure-github-repository-secrets","title":"Configure GitHub Repository Secrets","text":"<p>Configure secrets details in GitHub repo as described here in create GitHub secrets. Use below values mapped to relevant secrets in GitHub. </p> <pre><code># AZURE_SUBSCRIPTION_ID\necho $SUBSCRIPTION_ID # AZURE_TENANT_ID   \necho $AZURE_TENANT    # AZURE_CLIENT_ID      \necho $APP_ID             </code></pre>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/#configure-github-repository-variables","title":"Configure GitHub Repository Variables","text":"<p>Configure repository variables in GitHub repo as described here in create GitHub variables. Use below values mapped to relevant variables in GitHub. </p> <pre><code># LOCATION: Azure region where resources will be deployed\nLOCATION=&lt;location. e.g. eastus&gt;\n\n# RESOURCE_GROUP: Name of the resource group which will be created and resources will be deployed\nRESOURCE_GROUP=&lt;resource group name&gt;\n\n# (OPTIONAL)CONTAINER_REGISTRY_NAME: Unique name of the container registry which will be created and where images will be imported\nCONTAINER_REGISTRY_NAME=&lt;container registry name&gt;\n</code></pre> <p>Note</p> <p>Repository variables <code>CONTAINER_REGISTRY_NAME</code> is only needed by workflow, if you wish the images to be deployed from private ACR.</p> <p>You may chose to skip defining this variable and the workflow will use the public github container registry images to deploy the images.</p>"},{"location":"aca/06-aca-iac-bicep/ci-cd-git-action/#trigger-github-actions-workflow","title":"Trigger GitHub Actions Workflow","text":"<p>With these steps completed, you are now ready to trigger the GitHub Actions workflow named Build and deploy infrastructure as code to Azure using workflow dispatch to deploy the infrastructure components of the application.</p> <p>Success</p> <p>Your GitHub Actions workflow should be triggered and the infrastructure components of our application should be deployed successfully.</p> <p></p> Want to delete the resources deployed by the workflow? <p>Trigger the workflow again using workflow dispatch and select checkbox option.</p> <p></p>"},{"location":"aca/06-aca-iac-bicep/iac-bicep/","title":"Build the Infrastructure as Code Using Bicep","text":"<p>Module Duration</p> <p>30 minutes</p> <p>Note</p> <p>If you're not interested in manually deploying the Bicep files or creating the container registry yourself, and prefer not to delve into the details of how they work, then you can skip this section and head directly to either Build the Infrastructure as Code Using Bicep and Github or Build the Infrastructure as Code Using Bicep and Azure DevOps depending on your DevOps tool of choice.</p> <p>To begin, we need to define the Bicep modules that will be required to generate the Infrastructure code. Our goal for this module is to have a freshly created resource group that encompasses all the necessary resources and configurations - such as connection strings, secrets, environment variables, and Dapr components - which we utilized to construct our solution. By the end, we will have a new resource group that includes the following resources.</p> <p></p> <p>Note</p> <p>To simplify the execution of the module, we will assume that you have already created latest images of three services and pushed them to a container registry. This section below guides you through different options of getting images pushed to either Azure Container Registry (ACR) or GitHub Container Registry (GHCR).</p>"},{"location":"aca/06-aca-iac-bicep/iac-bicep/#1-add-the-needed-extension-to-vs-code","title":"1. Add the Needed Extension to VS Code","text":"<p>To proceed, you must install an extension called Bicep. This extension will simplify building Bicep files as it offers IntelliSense, Validation, listing all available resource types, etc..</p>"},{"location":"aca/06-aca-iac-bicep/iac-bicep/#2-deploy-the-infrastructure-and-create-the-components","title":"2. Deploy the Infrastructure and Create the Components","text":"<p>Ensure you are still connected to the Azure subscription you created in the previous module. If not, run the following command to connect to the subscription:</p> <pre><code>az login --use-device-code\n\n# Set the default subscription only needed if you have multiple subscriptions\naz account set --subscription &lt;your subscription id&gt;\n</code></pre> <p>Start by creating a new resource group which will contain all the resources to be created by the Bicep scripts.</p> <pre><code>export RESOURCE_GROUP=\"&lt;your RG name&gt;\"\nexport LOCATION=\"&lt;your location&gt;\"\naz group create \\\n--name $RESOURCE_GROUP \\\n--location $LOCATION\n</code></pre> <p>Create a parameters file which will simplify the invocation of the main bicep file. To achieve this, right click on file <code>main.bicep</code> and select Generate Parameter File.  This will result in creating a file named <code>main.parameters.json</code> similar to the file below:</p> Example main.parameters.json <pre><code>{\n\"$schema\": \"https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#\",\n\"contentVersion\": \"1.0.0.0\",\n\"parameters\": {\n\"prefix\": {\n\"value\": \"\"\n},\n\"suffix\": {\n\"value\": \"\"\n},\n\"tags\": {\n\"value\": {}\n},\n\"backendProcessorServiceName\": {\n\"value\": \"tasksmanager-backend-processor\"\n},\n\"backendApiServiceName\": {\n\"value\": \"tasksmanager-backend-api\"\n},\n\"frontendWebAppServiceName\": {\n\"value\": \"tasksmanager-frontend-webapp\"\n},\n\"serviceBusTopicName\": {\n\"value\": \"tasksavedtopic\"\n},\n\"serviceBusTopicAuthorizationRuleName\": {\n\"value\": \"tasksavedtopic-manage-policy\"\n},\n\"cosmosDbDatabaseName\": {\n\"value\": \"tasksmanagerdb\"\n},\n\"cosmosDbCollectionName\": {\n\"value\": \"taskscollection\"\n},\n\"sendGridKeySecretValue\": {\n\"value\": \"\"\n},\n\"sendGridEmailFrom\": {\n\"value\": \"&lt;SEND_GRID_FROM_EMAIL&gt;\"\n},\n\"sendGridEmailFromName\": {\n\"value\": \"Tasks Tracker Notification\"\n},\n\"externalTasksQueueName\": {\n\"value\": \"external-tasks-queue\"\n},\n\"externalTasksContainerBlobName\": {\n\"value\": \"externaltasksblob\"\n},\n\"externalStorageKeySecretName\": {\n\"value\": \"external-azure-storage-key\"\n},\n\"scheduledJobCron\": {\n\"value\": \"5 0 * * *\"\n},\n\"secretStoreComponentName\": {\n\"value\": \"secretstoreakv\"\n},\n\"containerRegistryName\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;\"\n},\n\"backendProcessorServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-processor:latest\"\n},\n\"backendApiServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-api:latest\"\n},\n\"frontendWebAppServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-frontend-webapp:latest\"\n},\n\"frontendWebAppPortNumber\": {\n\"value\": 80\n},\n\"backendApiPortNumber\": {\n\"value\": 80\n},\n\"backendProcessorPortNumber\": {\n\"value\": 80\n}\n}\n}\n</code></pre> <p>Note</p> <p>To use this file, you need to edit this generated file and provide values for the parameters. You can use the same values shown above in sample file. </p> <p>You only need to replace parameter values between the angle brackets <code>&lt;&gt;</code> with values related to your Azure Resources.</p> <p>Next, we will prepare container images for the three container apps and update the values in <code>main.parameters.json</code> file. You can do so by any of the three options below:</p> Option 1: Build and Push the Images to Azure Container Registry (ACR)Option 2: Import pre-built public images to your private Azure Container RegistryOption 3: Use the pre-built images from the public repository <ol> <li> <p>Create an Azure Container Registry (ACR) inside the newly created Resource Group:</p> <pre><code>export CONTAINER_REGISTRY_NAME=\"&lt;your ACR name&gt;\"\naz acr create \\\n--resource-group $RESOURCE_GROUP \\\n--name $CONTAINER_REGISTRY_NAME \\\n--sku Basic\n</code></pre> </li> <li> <p>Build and push the images to ACR. Make sure you are at the root project directory when executing the following commands:</p> <pre><code>## Build Backend API on ACR and Push to ACR\naz acr build --registry $CONTAINER_REGISTRY_NAME \\\n--image \"tasksmanager/tasksmanager-backend-api\" \\\n--file 'TasksTracker.TasksManager.Backend.Api/Dockerfile' .\n\n## Build Frontend Web App on ACR and Push to ACR\naz acr build --registry $CONTAINER_REGISTRY_NAME \\\n--image \"tasksmanager/tasksmanager-frontend-webapp\" \\\n--file 'TasksTracker.WebPortal.Frontend.Ui/Dockerfile' .\n</code></pre> </li> <li> <p>Update the <code>main.parameters.json</code> file and add the following values, replace the &lt;&gt; with your values:</p> <pre><code>\"containerRegistryName\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;\"\n},\n\"backendProcessorServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-processor:latest\"\n},\n\"backendApiServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-api:latest\"\n},\n\"frontendWebAppServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-frontend-webapp:latest\"\n}\n</code></pre> </li> </ol> <p>All the container image are available in a public image repository. If you do not wish to build the container images from code directly, you can import it directly into  your private container instance as shown below.</p> <ol> <li> <p>Create an Azure Container Registry (ACR) inside the newly created Resource Group:</p> <pre><code>$CONTAINER_REGISTRY_NAME=\"&lt;your ACR name&gt;\"\naz acr create `\n--resource-group $RESOURCE_GROUP `\n--name $CONTAINER_REGISTRY_NAME `\n--sku Basic\n</code></pre> </li> <li> <p>Import the images to your private ACR as shown below:</p> <pre><code>    az acr import `\n--name $CONTAINER_REGISTRY_NAME `\n--image tasksmanager/tasksmanager-backend-api `\n--source ghcr.io/azure/tasksmanager-backend-api:latest\n\naz acr import  `\n--name $CONTAINER_REGISTRY_NAME `\n--image tasksmanager/tasksmanager-frontend-webapp `\n--source ghcr.io/azure/tasksmanager-frontend-webapp:latest\n\naz acr import  `\n--name $CONTAINER_REGISTRY_NAME `\n--image tasksmanager/tasksmanager-backend-processor `\n--source ghcr.io/azure/tasksmanager-backend-processor:latest\n</code></pre> </li> <li> <p>Update the <code>main.parameters.json</code> file with the container registry name and the container images names as shown below:</p> <pre><code>{\n\"containerRegistryName\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;\"\n},\n\"backendProcessorServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-processor:latest\"\n},\n\"backendApiServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-backend-api:latest\"\n},\n\"frontendWebAppServiceImage\": {\n\"value\": \"&lt;CONTAINER_REGISTRY_NAME&gt;.azurecr.io/tasksmanager/tasksmanager-frontend-webapp:latest\"\n}\n}\n</code></pre> </li> </ol> <p>All the container image are available in a public image repository. If you do not wish to build the container images from code directly, you can use the pre-built images from the public repository as shown below.</p> <p>The public images can be set directly in the <code>main.parameters.json</code> file:</p> <pre><code>{\n\"containerRegistryName\": {\n\"value\": \"\"\n},\n\"backendApiServiceImage\": {\n\"value\": \"ghcr.io/azure/tasksmanager-backend-api:latest\"\n},\n\"frontendWebAppServiceImage\": {\n\"value\": \"ghcr.io/azure/tasksmanager-frontend-webapp:latest\"\n},\n}   </code></pre> <p>Start the deployment by calling <code>az deployment group create</code>. To accomplish this, open the shell console and use the content below.</p> <pre><code>az deployment group create \\\n--resource-group $RESOURCE_GROUP \\\n--template-file \"./bicep/main.bicep\" \\\n--parameters \"./bicep/main.parameters.json\"\n</code></pre> <p>The Azure CLI will take the Bicep module and start creating the deployment in the resource group.</p>"},{"location":"aca/06-aca-iac-bicep/iac-bicep/#verify-the-final-results","title":"Verify the Final Results","text":"<p>Success</p> <p>Upon successful deployment, you should observe all resources generated within the designated resource group. Additionally, you may navigate to the <code>Deployments</code> section to confirm that the ARM templates have been deployed, which should resemble the image provided below:</p> <p></p>"},{"location":"aca/12-contributing/1-contribution-guide/","title":"Contribution Guide","text":"<p>If you'd like to contribute to this guide, please read the following guidelines. Contributors are more than welcome to share your learnings with others from a centralized location.</p>"},{"location":"aca/12-contributing/1-contribution-guide/#what-can-i-do","title":"What Can I Do?","text":"<ul> <li>Submit an issue or suggestion</li> <li>Minor update or fix to an existing challenge and adding a new challenge</li> </ul>"},{"location":"aca/12-contributing/1-contribution-guide/#contributing","title":"Contributing","text":"<p>This project welcomes contributions and suggestions.  Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.</p> <p>When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p> <p>This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"aca/12-contributing/2-Submit-issue-suggestion/","title":"Support","text":""},{"location":"aca/12-contributing/2-Submit-issue-suggestion/#how-to-file-issues-and-get-help","title":"How to file issues and get help","text":"<p>This project uses GitHub Issues to track bugs and feature requests. Please search the existing  issues before filing new issues to avoid duplicates.  For new issues, file your bug or  feature request as a new Issue.</p> <p>There are two templates added to the repo for the following requests:</p> <ul> <li>Bug report</li> <li>Suggestion report </li> </ul>"},{"location":"aca/12-contributing/3-minor-update-fix/","title":"Typos, minor updates, or fixes to existing challenges","text":"<p>Whenever you are submitting any changes to the guide, please follow these recommendations:</p> <ul> <li>Always fork repository to your own account for applying modifications</li> <li>Do not combine multiple changes to one pull request, please submit any challenges and documentation updates using separate PRs</li> <li>If you are submitting multiple challenges, please create specific PR for each of them</li> <li>If you are submitting typo or documentation fix, you can combine modifications to single PR where suitable</li> </ul>"},{"location":"aca/13-appendix/01-run-debug-dapr-app-vscode/","title":"Debug and Launch Dapr Applications in VSCode","text":"<p>This page shows you how to configure VSCode to run and debug multiple Dapr applications at same time.</p>"},{"location":"aca/13-appendix/01-run-debug-dapr-app-vscode/#debug-and-launch-dapr-applications-in-vscode","title":"Debug and launch Dapr applications in VSCode","text":"<p>We need to update VS code <code>tasks.json</code> and <code>launch.json</code> configuration files included in your workspace. Once completed you should be able to use the Run and Debug button on the activity bar within  VS Code to launch all services to be able to debug them locally.</p> <p>First we need to add a new launch configuration for the Backend Web API and Frontend Web App projects.  To accomplish this, open file <code>launch.json</code> and add the two configurations shown below. </p> <p>Note</p> <p>Make sure you append the configurations below to the existing array instead of replacing what you have. This way you will preserve your existing configuration and simply add two new ones. </p> Looking for complete launch.json? launch.json <pre><code>{\n\"version\": \"0.2.0\",\n\"configurations\": [\n{\n\"name\": \"Launch (web app)\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"build-backend-api\",\n\"program\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/bin/Debug/net6.0/TasksTracker.WebPortal.Frontend.Ui.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n}\n},\n{\n\"name\": \"Launch (backend api)\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"build-webapp-ui\",\n\"program\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/bin/Debug/net6.0/TasksTracker.TasksManager.Backend.Api.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n}\n},\n{\n\"name\": \"Launch (background processor)\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"build-processor-svc\",\n\"program\": \"${workspaceFolder}/TasksTracker.Processor.Backend.Svc/bin/Debug/net6.0/TasksTracker.Processor.Backend.Svc.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.Processor.Backend.Svc\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n}\n},\n{\n\"name\": \".NET Core Attach\",\n\"type\": \"coreclr\",\n\"request\": \"attach\"\n},\n{\n\"name\": \"Launch (backend api) with Dapr\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"backend-api-dapr-debug\",\n\"program\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/bin/Debug/net6.0/TasksTracker.TasksManager.Backend.Api.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n},\n\"postDebugTask\": \"daprd-down-backend-api\"\n},\n{\n\"name\": \"Launch (web app) with Dapr\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"webapp-ui-dapr-debug\",\n\"program\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/bin/Debug/net6.0/TasksTracker.WebPortal.Frontend.Ui.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n},\n\"postDebugTask\": \"webapp-ui-daprd-down\"\n},\n{\n\"name\": \"Launch (background processor) with Dapr\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"processor-svc-dapr-debug\",\n\"program\": \"${workspaceFolder}/TasksTracker.Processor.Backend.Svc/bin/Debug/net6.0/TasksTracker.Processor.Backend.Svc.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.Processor.Backend.Svc\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n},\n\"postDebugTask\": \"processor-svc-daprd-down\"\n}\n],\n\"compounds\": [\n{\n\"name\": \"RunAll\",\n\"configurations\": [\"Launch (web app)\", \"Launch (backend api)\", \"Launch (background processor)\",],\n\"stopAll\": true\n},\n{\n\"name\": \"RunAll with Dapr\",\n\"configurations\": [ \"Launch (backend api) with Dapr\", \"Launch (web app) with Dapr\", \"Launch (background processor) with Dapr\", ],\n\"stopAll\": true\n}\n]\n}\n</code></pre> <p>Note</p> <p>The configuration below assumes that you are using .net 6. If you are using a different .net version make sure you update the paths to use the correct version.  For example if using .net 7 then change the path to say net7.0 instead of net6.0.</p> launch.json <pre><code>{\"configurations\":\n[\n{\n\"name\": \"Launch (backend api) with Dapr\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"backend-api-dapr-debug\",\n\"program\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/bin/Debug/net6.0/TasksTracker.TasksManager.Backend.Api.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n},\n\"postDebugTask\": \"daprd-down-backend-api\"\n},\n{\n\"name\": \"Launch (web app) with Dapr\",\n\"type\": \"coreclr\",\n\"request\": \"launch\",\n\"preLaunchTask\": \"webapp-ui-dapr-debug\",\n\"program\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/bin/Debug/net6.0/TasksTracker.WebPortal.Frontend.Ui.dll\",\n\"args\": [],\n\"cwd\": \"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui\",\n\"stopAtEntry\": false,\n\"serverReadyAction\": {\n\"action\": \"openExternally\",\n\"pattern\": \"\\\\bNow listening on:\\\\s+(https?://\\\\S+)\"\n},\n\"env\": {\n\"ASPNETCORE_ENVIRONMENT\": \"Development\"\n},\n\"sourceFileMap\": {\n\"/Views\": \"${workspaceFolder}/Views\"\n},\n\"postDebugTask\": \"webapp-ui-daprd-down\"\n}\n]}\n</code></pre> <p>Note</p> <p>We have a <code>preLaunchTask</code> and a <code>postDebugTask</code> which we need to define right now. Those tasks are Dapr tasks.</p> <p>The Dapr VSCode extension we have previously installed helps us to define those pre- and post-debug  tasks. </p> <p>To accomplish this, open the file tasks.json and click Ctrl+Shift+P, and type Dapr: Scaffold Dapr Tasks. </p> <p>The Dapr VS Code extension will allow us to manage Dapr application and test it out in an easier way, the below image shows a full list of helper commands.</p> <p></p> <p>Now we will add 4 tasks, for each application, there will be a task to support the <code>preLaunch</code> activity and the <code>postDebug</code> activity (Terminate/Exit Dapr Sidecar process), so open file tasks.json and add the tasks below:</p> tasks.json <pre><code>{\n\"tasks\": [\n{\n\"appId\": \"tasksmanager-backend-api\",\n\"appPort\": [web api application port number found under properties-&gt;launchSettings.json. e.g. 7112],\n\"httpPort\": 3500,\n\"grpcPort\": 50001,\n\"appSsl\": true,\n\"label\": \"backend-api-dapr-debug\",\n\"type\": \"dapr\",\n\"dependsOn\": \"build-backend-api\",\n// Uncomment this line after adding Azure Cosmos DB in module 4\n//\"componentsPath\": \"./components\"\n},\n{\n\"appId\": \"tasksmanager-backend-api\",\n\"label\": \"daprd-down-backend-api\",\n\"type\": \"daprd-down\"\n},\n{\n\"appId\": \"tasksmanager-frontend-webapp\",\n\"appPort\": [frontend application port number found under properties-&gt;launchSettings.json. e.g. 7112],\n\"httpPort\": 3501,\n\"grpcPort\": 50002,\n\"appSsl\": true,\n\"label\": \"webapp-ui-dapr-debug\",\n\"type\": \"dapr\",\n\"dependsOn\": \"build-webapp-ui\"\n},\n{\n\"appId\": \"tasksmanager-frontend-webapp\",\n\"label\": \"webapp-ui-daprd-down\",\n\"type\": \"daprd-down\"\n}\n]}\n</code></pre> Curious to learn more about the tasks.json file above? <ul> <li>The tasks with the label <code>backend-api-dapr-debug</code> will invoke the <code>daprd</code> task. This task is similar to calling dapr run from CLI.</li> <li>We are setting the appPort, httpPort, and grpcPort properties (grpcPort is needed in future modules when we start using the state manager building block.  If you didn't set it, you might face a similar issue)</li> <li>We are setting the \u201ccomponentsPath\u201d property. This is needed when start working with the state manager, pub/sub, etc.</li> <li>We are setting the dependsOn property, so this means this task will fire after the dependsOn tasks complete successfully. We need to add those dependsOn tasks.</li> <li>The tasks with the label <code>daprd-down-backend-api</code> will terminate the Dapr Sidecar process. This will be used for the <code>postDebug</code> activity in configuration.json.</li> <li>For a complete list of available properties please check this link.</li> </ul> <p>Next let's add the dependsOn tasks. Open <code>tasks.json</code> and add the tasks below:</p> tasks.json<pre><code>{\n\"label\": \"build-backend-api\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"build\",\n\"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/TasksTracker.TasksManager.Backend.Api.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"build-webapp-ui\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"build\",\n\"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/TasksTracker.WebPortal.Frontend.Ui.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n}\n</code></pre> Looking for complete tasks.json? tasks.json <pre><code>{\n\"version\": \"2.0.0\",\n\"tasks\": [\n{\n\"label\": \"build-backend-api\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"build\",\n\"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/TasksTracker.TasksManager.Backend.Api.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"publish-backend-api\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"publish\",\n\"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/TasksTracker.TasksManager.Backend.Api.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"watch-backend-api\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"watch\",\n\"run\",\n\"--project\",\n\"${workspaceFolder}/TasksTracker.TasksManager.Backend.Api/TasksTracker.TasksManager.Backend.Api.csproj\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"build-webapp-ui\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"build\",\n\"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/TasksTracker.WebPortal.Frontend.Ui.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"publish-webapp-ui\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"publish\",\n\"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/TasksTracker.WebPortal.Frontend.Ui.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"watch-webapp-ui\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"watch\",\n\"run\",\n\"--project\",\n\"${workspaceFolder}/TasksTracker.WebPortal.Frontend.Ui/TasksTracker.WebPortal.Frontend.Ui.csproj\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"build-processor-svc\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"build\",\n\"${workspaceFolder}/TasksTracker.Processor.Backend.Svc/TasksTracker.Processor.Backend.Svc.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"publish-processor-svc\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"publish\",\n\"${workspaceFolder}/TasksTracker.Processor.Backend.Svc/TasksTracker.Processor.Backend.Svc.csproj\",\n\"/property:GenerateFullPaths=true\",\n\"/consoleloggerparameters:NoSummary\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"watch-processor-svc\",\n\"command\": \"dotnet\",\n\"type\": \"process\",\n\"args\": [\n\"watch\",\n\"run\",\n\"--project\",\n\"${workspaceFolder}/TasksTracker.Processor.Backend.Svc/TasksTracker.Processor.Backend.Svc.csproj\"\n],\n\"problemMatcher\": \"$msCompile\"\n},\n{\n\"label\": \"build-all\",\n\"dependsOn\": [\n\"build-backend-api\",\n\"build-webapp-ui\",\n\"build-processor-svc\"\n],\n\"problemMatcher\": [],\n\"group\": {\n\"kind\": \"build\",\n\"isDefault\": true\n}\n},\n{\n\"appId\": \"tasksmanager-backend-api\",\n\"appPort\": 7088,\n\"httpPort\": 3500,\n\"grpcPort\": 50001,\n\"appSsl\": true,\n\"label\": \"backend-api-dapr-debug\",\n\"type\": \"dapr\",\n\"dependsOn\": \"build-backend-api\",\n\"componentsPath\": \"./components\"\n},\n{\n\"appId\": \"tasksmanager-backend-api\",\n\"label\": \"daprd-down-backend-api\",\n\"type\": \"daprd-down\"\n},\n{\n\"appId\": \"tasksmanager-frontend-webapp\",\n\"appPort\": 7208,\n\"httpPort\": 3501,\n\"grpcPort\": 50002,\n\"appSsl\": true,\n\"label\": \"webapp-ui-dapr-debug\",\n\"type\": \"dapr\",\n\"dependsOn\": \"build-webapp-ui\"\n},\n{\n\"appId\": \"tasksmanager-frontend-webapp\",\n\"label\": \"webapp-ui-daprd-down\",\n\"type\": \"daprd-down\"\n},\n{\n\"appId\": \"tasksmanager-backend-processor\",\n\"appPort\": 7263,\n\"httpPort\": 3502,\n\"grpcPort\": 50003,\n\"appSsl\": true,\n\"label\": \"processor-svc-dapr-debug\",\n\"type\": \"dapr\",\n\"dependsOn\": \"build-processor-svc\",\n\"componentsPath\": \"./components\"\n},\n{\n\"appId\": \"tasksmanager-backend-processor\",\n\"label\": \"processor-svc-daprd-down\",\n\"type\": \"daprd-down\"\n}\n]\n}\n</code></pre> <p>Lastly, we need to add a <code>compound launch</code> property, so we launch and debug both applications together. </p> <p>To accomplish this, open the file <code>launch.json</code> again and add the below array after the <code>configuration</code> array.</p> launch.json<pre><code>\"compounds\": [\n{\n\"name\": \"RunAll with Dapr\",\n\"configurations\": [\n\"Launch (backend api) with Dapr\",\n\"Launch (web app) with Dapr\"\n],\n\"stopAll\": true\n}\n]\n</code></pre> <p>Success</p> <p>If all is done correctly, you should be able to see a debug configuration named <code>RunAll with Dapr</code> and you should be able to just hit ++F5++, sit breakpoints and debug both applications locally in VS Code.</p> <p></p>"},{"location":"aca/13-appendix/02-github-local-codespaces/","title":"Inner loop, testing your changes locally or using GitHub Codespaces","text":"<ul> <li><code>docs/aca</code> folder , contains all the mark-down documentation files for all the modules</li> <li><code>docs/assets</code> folder, contains all the images, slides, and files used in the lab</li> <li>This site uses, Material for MkDocs.  Take some time to familiarize yourself with the theme and the features it provides.</li> </ul>"},{"location":"aca/13-appendix/02-github-local-codespaces/#locally","title":"Locally","text":"<p>Checkout the repo locally using below command:</p> <pre><code>git clone  https://github.com/Azure/aca-dotnet-workshop.git\n</code></pre> <p>Using bash terminal or wsl terminal, navigate to the repo root folder and run the below command to build and run the website locally:</p> <pre><code>make docs-local\n</code></pre>"},{"location":"aca/13-appendix/02-github-local-codespaces/#using-github-codespaces","title":"Using GitHub Codespaces","text":"<p>This repo has a github codespaces dev container defined. This container is based on ubuntu 20.04 and contains all the libraries and components to run github pages locally in Github Codespaces. To test your changes follow these steps:</p> <ul> <li>Enable GitHub codespaces for your account</li> <li>Fork this repo</li> <li>Open the repo in github codespaces</li> <li>Wait for the container to build and connect to it</li> <li>Run the website in github codespaces using below command</li> </ul> <p><pre><code>make docs-local\n</code></pre> </p>"}]}